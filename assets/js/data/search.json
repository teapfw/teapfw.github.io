[
  
  {
    "title": "Olivia",
    "url": "/posts/olivia/",
    "categories": "Reflections",
    "tags": "",
    "date": "2025-01-21 19:00:00 -0500",
    





    
    "snippet": "A letter from a friend…An incredibly beautiful little girl, Olivia, was just born to my cousin. Lying upright in the hospital bed, she was cradling the baby in her arms; I had never seen a woman’s ...",
    "content": "A letter from a friend…An incredibly beautiful little girl, Olivia, was just born to my cousin. Lying upright in the hospital bed, she was cradling the baby in her arms; I had never seen a woman’s face so blissfully lost in her own world. After a minute, raising her eyes momentarily to let them rest on the horizon, she caught me staring. “Do you want to hold her?” My heart jumped. I had never held a baby. I don’t even own a cat. But, somehow, one step forward and one heart attack later my arms were the princess’ throne. She was still, she was warm, she was small. Olivia, you’re so new that you’re wrinkled! Where did you begin? Twenty minutes ago you were crying a storm on your mother’s chest, eyes closed, the umbilical cord still attached. You couldn’t have begun when the cord was cut; you were already vivid then. A couple minutes earlier you had your little head stuck outside and your little feet still inside, and jostled with every gram of energy you had. Still just as alive. A few more minutes earlier and you had the same kicks of energy, but hidden away in the womb as though playing a game of peekaboo. But, as you will soon learn, not because you can’t be seen are you not there. You must have begun earlier, then. Perhaps when your parents named you. But, I remember they changed their minds, and Sofia was your name first, weeks before you were called Olivia. So are you really Sofia or Olivia? You can’t be two people at once, with two different ages and two different minds. This is nonsense, it can’t be the name. Earlier, then. When you began to think? But exactly how many neurons does it take to think, and when exactly did you gain that number? Am I human while I sleep? Perhaps when your heart began to beat, surely. Yet why that organ and not another? Life depends on many organs, not just one of them. Those AEDs don’t say, detecting a still heart, “Stand clear of the human tissue!” It must be earlier still. But how further back can we go? There’s only one critical moment left. The moment your substance first began to work on itself. The moment your being began to stretch itself out into life and absorb the life offered it. The moment love made a third from two. That must be it. Olivia was conceived in a whisper of some hour of day or night, too discrete for even her own parents to have heard it, because it happened sometime after something else. But it was then, it had to have been then when you began."
  },
  
  {
    "title": "Artificial Potential Fields - The Secant Method",
    "url": "/posts/artificial_potential_field_secant/",
    "categories": "Robotics",
    "tags": "controls, apf",
    "date": "2023-02-01 23:00:00 -0500",
    





    
    "snippet": "Artificial potential fields (APFs) offer an interesting approach to path planning. The use of “fake forces” makes it intuitive to combine the effects of different elements in the planning scene. Ho...",
    "content": "Artificial potential fields (APFs) offer an interesting approach to path planning. The use of “fake forces” makes it intuitive to combine the effects of different elements in the planning scene. However, a common a drawback is the creation of local minima, which prevent guaranteed convergence on the target.MathematicsThe topographic height or potential of a point is denoted \\(\\psi (\\mathbf{z})\\). In the standard technique,\\[\\psi (\\mathbf{z}) = k_p \\mathbf{z}^\\intercal \\mathbf{z} + \\sum_{i=1} k_{o,i} \\frac{\\mathbf{z}^\\intercal \\mathbf{z}}{\\mathbf{s_i}^\\intercal \\mathbf{s_i}}\\]where \\(\\mathbf{z}\\) is the vector from the target to the point in space \\(\\mathbf{z}\\), while \\(\\mathbf{s_i}\\) is from the obstacle to \\(\\mathbf{z}\\).Secant MethodThe Secant Method [1] was developed as a way to eliminate the local minimum artifact of APFs. The technique cleverly creates a potential field whose gradiant never points away from the target. Obstacles form “mountain ranges” whose peaks extend radially from the target, as opposed to circular peaks produced by the traditional technique. This is made possible by weighting the potential field with an additional factor in the range \\([1, \\inf)\\) as a means of encoding proximity to the obstacle in a manner biased toward points where the obstacle obstructs a direct path to the target. This is achieved with a secant function having argument \\(\\theta_i \\in [0, \\frac{\\pi}{2})\\).\\[\\psi (\\mathbf{z}) = k_p \\mathbf{z}^\\intercal \\mathbf{z} + \\frac{1}{2} \\sum_{i=1} k_{o,i} \\frac{\\mathbf{z}^\\intercal \\mathbf{z} \\sec^2(\\theta_i)}{\\mathbf{s_i}^\\intercal \\mathbf{s_i}}\\]The Secant Method yields the following potential field contour plots. An identical map with color bars: References    K. J. Ahlin, N. Sadegh, and A.-P. Hu, “The Secant Method: Global Trajectory Planning With Variable Radius, Solid Obstacles,” in Volume 3: Modeling and Validation; Multi-Agent and Networked Systems; Path Planning and Motion Control; Tracking Control Systems; Unmanned Aerial Vehicles (UAVs) and Application; Unmanned Ground and Aerial Vehicles; Vibration in Mechanical Systems; Vibrations and Control of Systems; Vibrations: Modeling, Analysis, and Control, Atlanta, Georgia, USA, Sep. 2018, p. V003T32A015, doi: 10.1115/DSCC2018-9176."
  },
  
  {
    "title": "Particle Catching",
    "url": "/posts/particle_catching/",
    "categories": "Robotics",
    "tags": "planning",
    "date": "2022-10-21 00:00:00 -0400",
    





    
    "snippet": "The challenge involves tracking a target particle and planning a path which brings the player into contact with the target at a particular time.InvestigationTrivial approachThe trivial solution is ...",
    "content": "The challenge involves tracking a target particle and planning a path which brings the player into contact with the target at a particular time.InvestigationTrivial approachThe trivial solution is to simply command the particle to prosecute the target’s current position, without extrapolating its behavior into the future. We don’t consider this possibility further.Naive approachThe next simplest solution is to predict the target’s position at the specified impact time and plan a direct course to that location. The impact location is found by integrating the target’s acceleration and using its current position and velocity as initial conditions. The speed of the player along its trajectory is equal to the distance it will travel divided by the impact time.ResultsMatching target velocityIt is desirable to meet the target not only at a given position in space but also while traveling at its same velocity. This would be a “soft” catch instead of a hard collision.To achieve this, a path is generated at every instant time which smoothly joints the player’s current position with the expected target location. The path is generated as a Bezier curve with end tangents defined by the player’s current velocity and the target’s expected velocity.In path coordinates, the player’s speed must be a function of time. A linear model would suffice to meet strictly the target’s position; however, it offers insufficient degrees of freedom to reach the same position at a specified speed. A quadratic speed model would work.\\[\\dot s(t) = a_2t^2 + a_1t + a_0\\]The three boundary conditions require:      The speed begin as equal to the player’s current speed\\[\\dot s(0) = v_0 = a_0\\]        The speed end as equal to the expected target’s speed\\[\\dot s(t_f) = v_f = a_2t_f^2 + a_1t_f + a_0\\]        The distance traveled by the player must be equal to the generated path’s length\\[d = \\int_0^{t_f} \\dot s(t) dt = \\frac{1}{3} a_2t_f^3 + \\frac{1}{2} a_1t_f^2 + a_0t_f\\]  Solving the system of linear equations yields:\\[a_2 = \\frac{3(v_ft_f + v_0t_f - 2d)}{t_f^3} \\\\a_1 = \\frac{-2(v_ft_f + 2v_0t_f - 3d)}{t_f^2} \\\\a_0 = v_0\\]The player speed at the next simulated time-step is found as $\\dot s(dt)$. To calculate velocity, the tangent vector to the planned path at the next timestep is also required. First, $\\dot s(t)$ is integrated over the timestep to find $ds$, the distance traveled along the path. The parameter which yields this point along the Bezier curve is worked numerically and used to obtain the tangent vector at the particle’s next timestep. The commanded acceleration is finally obtained as the difference between the player’s next and current velocity.ResultsUnfortunately, it’s evident that variations in the target’s velocity cause large changes in the expected meet location, in turn producing rather wild player paths.Applying a filter to tracked accelerationWhen the player is further away from the target, it may make sense to filter rapid changes in the target’s behavior. Even small changes in acceleration extrapolate to large differences in the target’s future location; but if those changes are cyclic or noisy, the player ends up losing large amounts of energy by chasing a rapidly changing path.To test this theory, a simple weight is applied to the target’s acceleration when predicting its location and impact time. The weight caps at 1.0 and limits to 0.0 when the player is infinitely far from the target.ResultsThis is much better. The player still moves somewhat abruptly, leaving room for improvement. Use of a proper lowpass filter may introduce a “smoothing” lag and should be tried next.DetailsThe plots are generated via a sandbox written in Julia. The main control loop is very simple:for t in time_range    # Stage the target    p = Sinusoidal()    stage_path!(p, target, t)    # Control    c = N1()    path = controller!(c, target, player, impact_time - t, dt)    push!(planned_paths, path)    # Step particles    move_particle!(target, dt)    move_particle!(player, dt)endThe particle types are simple objects:struct Particle{T}    id::Int64    pos::Vector{Vector{T}}    vel::Vector{Vector{T}}    acl::Vector{Vector{T}}    function Particle(id::Int64)        new{Float64}(id, [fill(0.0, 3)], [fill(0.0, 3)], [fill(0.0, 3)])    endendThe target path is controlled by applying an acceleration:abstract type Path endstruct Linear &lt;: Path endstruct Quadratic &lt;: Path endstruct Sinusoidal &lt;: Path    w::Float64    m::Float64    function Sinusoidal()        new(2., 4.)    endendfunction stage_path!(path::Linear, particle::Particle, t::Float64)    particle.acl[end] = [0.0, 0.0, 0.0]endfunction stage_path!(path::Quadratic, particle::Particle, t::Float64)    particle.acl[end] = [0.0, 2.0, 0.0]endfunction stage_path!(path::Sinusoidal, particle::Particle, t::Float64)    particle.acl[end] = [0.0, -path.m*sin(path.w*t), 0.0]endWhile a sample controller commands player acceleration for the next timestep:abstract type Controller endstruct N1 &lt;: Controller endstruct N2 &lt;: Controller end# Based on standard position projectionfunction controller!(controller::N1, target::Particle, player::Particle, time2impact::Float64, dt::Float64)    predicted_target_pos = project_particle_pos(target, time2impact)    new_vel = (predicted_target_pos - player.pos[end]) / time2impact    player.acl[end] = (new_vel - player.vel[end]) / dt    # Return path points    points = []    for i in 0:0.05:1        push!(points, player.pos[end] + i*(predicted_target_pos - player.pos[end]))    end    return pointsend"
  }
  
]

